<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2016.2 (Build 618U)" ts="2016-06-04 02:31:01">
<Project name="MQTTClient" LastModified="2016-06-02 23:21:11.52613">
  <Items>
    <ProjectItem name="MQTTOptions.INC" type="MAC"></ProjectItem>
    <ProjectItem name="Net.MQTT.Agent" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.MessageCounter" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.MessageStatus" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.Subscription" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.SubscriptionTopic" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Aux.TaskList" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Client" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.Message" type="CLS"></ProjectItem>
    <ProjectItem name="Net.MQTT.MessageStore" type="CLS"></ProjectItem>
  </Items>
</Project>


<Routine name="MQTTOptions" type="INC" timestamp="64072,50236.541129"><![CDATA[
#; General
#define MQTTTraceIN(%type,%msg)		$$$MQTTTrace(%type,"I",%msg)
#define MQTTTraceOUT(%type,%msg)	$$$MQTTTrace(%type,"O",%msg)
#define MQTTTraceINF(%msg)			$$$MQTTTrace("INFO","S",%msg)
#define MQTTTraceERR(%msg)			$$$MQTTTrace("ERROR","S",%msg)
#define MQTTTrace(%type,%dir,%msg)	Set:(..trace) var=..traceTarget,@var@($I(@var),$ZDT($ZU(188),3,1,3),%dir,$Case(%type,"":"UNKNOWN",:%type))=%msg
#define MQTTEncodeNumber(%num)		$Reverse($ZWChar(%num))
#define MQTTDecodeNumber(%str)		$ZWAscii($Reverse(%str))

#; Fixed header
#define MQTTRetain			1
#define MQTTQoS1			2
#define MQTTQoS2			4
#define MQTTDup				8

#; Message types
#define MQTTCONNECT			16
#define MQTTCONNACK			32
#define MQTTPUBLISH			48
#define MQTTPUBACK			64
#define MQTTPUBREC			80
#define MQTTPUBREL			96
#define MQTTPUBCOMP			112
#define MQTTSUBSCRIBE		128
#define MQTTSUBACK			144
#define MQTTUNSUBSCRIBE		160
#define MQTTUNSUBACK		176
#define MQTTPINGREQ			192
#define MQTTPINGRESP		208
#define MQTTDISCONNECT		224
#define MQTTMsgType(%code)	$Case(%code,$$$MQTTCONNECT:"CONNECT",$$$MQTTCONNACK:"CONNACK",$$$MQTTPUBLISH:"PUBLISH",$$$MQTTPUBACK:"PUBACK",$$$MQTTPUBREC:"PUBREC",$$$MQTTPUBREL:"PUBREL",$$$MQTTPUBCOMP:"PUBCOMP",$$$MQTTSUBSCRIBE:"SUBSCRIBE",$$$MQTTSUBACK:"SUBACK",$$$MQTTUNSUBSCRIBE:"UNSUBSCRIBE",$$$MQTTUNSUBACK:"UNSUBACK",$$$MQTTPINGREQ:"PINGREQ",$$$MQTTPINGRESP:"PINGRESP",$$$MQTTDISCONNECT:"DISCONNECT",:"Unkown")

#; CONNECT
#define MQTTCleanSession	2
#define MQTTWillFlag		4
#define MQTTWillQoS1		8
#define MQTTWillQoS2		16
#define MQTTWillRetain		32
#define MQTTPasswordFlag	64
#define MQTTUsernameFlag	128

#; SUBSCRIBE
#define MQTTSubQoS1			1
#define MQTTSubQoS2			2
			
]]></Routine>


<Class name="Net.MQTT.Agent">
<Description><![CDATA[
The MQTT Agent is always started by a <class>Net.MQTT.Client</class> in the background to manage the real communication with the broker.
<p>The agent inherits its settings from the Client, which started it and it is responsible for:<ul>
<li>Building the TCP connection to the broker.</li>
<li>Executing the tasks created by the Client (and the Agent itself) based on the <class>Net.MQTT.Aux.TaskList</class> records.
 E.g.: sending various messages to the broker.</li>
<li>Keeping the connection alive by sending PING requests to the broker, when no other messages has been sent for a certain amount of time.</li>
<li>Listening for incoming messages from the broker and triggering appropriate actions based on the message type.</li>
</ul></p>]]></Description>
<Super>Net.MQTT.Client</Super>
<TimeChanged>64072,86206.197383</TimeChanged>
<TimeCreated>64051,64922.792357</TimeCreated>

<Property name="connected">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="device">
<Type>%String</Type>
</Property>

<Property name="saveIODev">
<Type>%String</Type>
</Property>

<Property name="transTable">
<Type>%String</Type>
<InitialExpression>##class(%IO.I.TranslationDevice).GetCharEncodingTable("UTF-8")</InitialExpression>
</Property>

<Property name="lastMessage">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($ZTimeStamp, 3, 1)</InitialExpression>
</Property>

<Property name="lastPing">
<Type>%TimeStamp</Type>
</Property>

<Property name="fatalError">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="StartListening">
<Description><![CDATA[
This method is called directly (as a background job) by the <class>Net.MQTT.Client</class> to start the Agent.
<p><var>pInitialState</var> is the XML serialized content of the calling Client object, from which the agent can populate its own properties.</p>
<p><var>pUsername</var> and <var>pPassword</var> are the optional credentials to be sent to the broker on connecting.</p>
<p>The Agent builds the TCP connection to the broker, sends a <b><var>CONNECT</var></b> message and then starts to communicate with the broker.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInitialState:%String,pUsername:%String="",pPassword:%String=""</FormalSpec>
<Implementation><![CDATA[
	Set ret = ""
	Set reader = ##class(%XML.Reader).%New()
	Do reader.Correlate("root", ..%ClassName(1))
	Set tSC = reader.OpenString(pInitialState)
	If $$$ISOK(tSC) && reader.Next(.agent) {
		Set tSC = agent.DoCONNECT(pUsername, pPassword)
		If $$$ISOK(tSC) {
			Do agent.Listen()
		}
		Else {
			Set ret = $System.Status.GetErrorText(tSC)
		}
	}
	Else {
		Set ret = "MQTT Agent cannot start (missing initial state)"
	}
]]></Implementation>
</Method>

<Method name="Listen">
<Description><![CDATA[
The main function of the Agent. Unless a fatal error happens, it runs in an endless loop, doing onw of the followin things in every loop:<ul>
<li>If a pending <class>Net.MQTT.Aux.TaskList</class> object can be found for the Agent's unique <property>connectionId</property>,
 it starts to execute the corresponding task, then signals the initiator of the task via the <class>%SYSTEM.Event</class> API.</li>
<li>If no response has arrived from the broker for the last PING request within the <property>KeepAliveInterval</property>
 it treats the connection to the broker broken and stops.</li>
<li>If no other messages has been sent to the broker for a certain amount of time (~ 80% of the ) <property>KeepAliveInterval</property>,
 it sends a PING request to keep the connection alive.</li>
<li>Listens for incoming messages.</li>
</ul>]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<Implementation><![CDATA[
	Use ..device
	$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> starts listening")
	Do SetIO^%NLS("RAW")
	While 1 {
		If ..fatalError {
			Quit
		}
		
		TRY {
			Set tSC = ##class(Net.MQTT.Aux.TaskList).AcquireNext(..connectionId, .taskId, .contextId, .action)
			If $$$ISOK(tSC) {
				If taskId '= "" {
					$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> processes task (" _taskId _ ")")
					Set tSC = $METHOD($this, "Do" _ action, taskId, contextId)
					Set tSC = ##class(Net.MQTT.Aux.TaskList).SignalTask(..connectionId, taskId, tSC, (''..debugMode))
				}
				ElseIf (..lastPing '= "") && ($System.SQL.DATEDIFF("s", ..lastPing, $ZDateTime($ZTimeStamp, 3, 1)) > ..KeepAliveInterval) {
					$$$MQTTTraceERR("PINGRESP message has not arrived from <" _ ..Host _ ":" _ ..Port _ "> within the timeout interval")
					Set ..fatalError = 1
				}
				ElseIf $System.SQL.DATEDIFF("s", ..lastMessage, $ZDateTime($ZTimeStamp, 3, 1)) > (..KeepAliveInterval * .8) {
					$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> sends ping")
					Set tSC = ..SendPINGREQ()
					If $$$ISERR(tSC) {
						$$$MQTTTraceERR("PINGREQ message cannot be sent to <" _ ..Host _ ":" _ ..Port _ ">")
						Set ..fatalError = 1
					}
				}
				Else {
					Set tSC = ..RecvMessage()
				}
			}
		}
		CATCH ex {
			Set tSC = ex.AsStatus()
		}
		
		If $$$ISERR(tSC) {
			$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		}
	}
	
	Do ..CloseDev()
	Use ..saveIODev
	
	Quit
]]></Implementation>
</Method>

<Method name="RecvMessage">
<Description><![CDATA[
Listens for incoming messages.
<p>First takes a 1 byte MQTT Header. The takes the following 1 to 4 bytes to define the remaining length of the message.
 Finally reads the remaining part of the message and triggers appropriate action based on the message type (extracted from the Header).</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 Set tSC = $$$OK
 TRY {	
	Read header#1:0 Set timeout = ('$Test)
	If 'timeout {
		$$$MQTTTraceIN("Header", header)
		Set type	= ..GetMessageType(header)
		Set typeT	= $$$MQTTMsgType(type)
		Set dup		= ..IsDuplicate(header)
		Set qos		= ..GetQoSLevel(header)
		Set retain	= ..IsRetain(header)
		
		Set multi = 1, length = 0, pos = 2, rl = ""
		For i = 1: 1: 4 {
			Read next#1:..ReadTimeout Set timeout = ('$Test)
			If timeout {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ typeT _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (missing Remaining Length)")
				Quit
			}
			Set rl = rl _ next
			Set next = $Ascii(next)
			Set length = length + ((next # 128) * multi)
			If next < 128 { Quit }
			Set multi = multi * 128
		}
		
		Set content = ""
		$$$MQTTTraceIN("Length", rl)
		If $$$ISOK(tSC) && (length > 0) {
			Read content#length:..ReadTimeout Set timeout = ('$Test)
			If timeout || ($Length(content) '= length) {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ typeT _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (missing content)")
			}
		}
		If $$$ISOK(tSC) {
			$$$MQTTTraceIN(typeT, header _ rl _ content)
		}
		Set tSC = $METHOD($this, "Recv" _ typeT, dup, qos, retain, content)
	}
 }
 CATCH ex {
	If ex.%IsA("%Exception.SystemException") && (ex.Name = "<READ>") {
		$$$MQTTTraceERR("MQTT broker probably closed TCP connection to <" _ ..Host _ ":" _ ..Port _ "> (READ error)")
		Set ..fatalError = 1
	}
	Set tSC = ex.AsStatus() 
 } 
 Quit tSC
]]></Implementation>
</Method>

<Method name="DoCONNECT">
<Description><![CDATA[
Builds the TCP connection to the MQTT broker and sends the <b><var>CONNECT</var></b> message.]]></Description>
<Internal>1</Internal>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> is starting")
	
	Set ..saveIODev = $IO
	If ('..connected) {
		Set ..device = "|TCP|" _ ..Port _ "|" _ $P($Job, ":")
		Open ..device:(..Host:..Port::::::):..ConnectTimeout Set timeout=('$Test)
		
		If timeout {
			$$$MQTTTraceERR("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> failed to start TCP connection")
			Quit $$$ERROR($$$GeneralError, "TCP Connection to <" _ ..Host _ ":" _ ..Port _ "> has not succeeded within the timeout interval")
		}
		Else {
			$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> started TCP connection")
			Set ..connected = 1
		}
	}
	
	Use ..device
	Do SetIO^%NLS("RAW")
	Set tSC = ..SendCONNECT(pUsername, pPassword)
	If $$$ISERR(tSC) {
		Do ..CloseDev()
	} 
	Use ..saveIODev
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoDISCONNECT">
<Description><![CDATA[
Sends a <b><var>DISCONNECT</var></b> message to the MQTT broker and closes the TCP connection.]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pConnectionId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendDISCONNECT()
	Do ..CloseDev()
	Use ..saveIODev
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoSUBSCRIBE">
<Description><![CDATA[
Sends a <b><var>SUBSCRIBE</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Idenifier.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>SUBSCRIBE</var></b> message must be stored in a <class>Net.MQTT.Aux.Subscription</class> object.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set topics = ##class(Net.MQTT.Aux.Subscription).GetTopicList(..ClientId, msgid, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendSUBSCRIBE(msgid, topics, dup)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoUNSUBSCRIBE">
<Description><![CDATA[
Sends a <b><var>UNSUBSCRIBE</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Idenifier.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>UNSUBSCRIBE</var></b> message must be stored in a <class>Net.MQTT.Aux.Subscription</class> object.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set topics = ##class(Net.MQTT.Aux.Subscription).GetTopicList(..ClientId, msgid, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendUNSUBSCRIBE(msgid, topics, dup)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBLISH">
<Description><![CDATA[
Sends a <b><var>PUBLISH</var></b> message to the MQTT broker. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a <class>Net.MQTT.Aux.MessageStore</class> object ID.
If it contains a colon, this is a repeated attempt, because no acknowledge has been received from the broker within the defined timout period.</p>
<p>The details of the <b><var>PUBLISH</var></b> message are stored in the referenced <class>Net.MQTT.Aux.MessageStore</class> object.</p>
<p>On QoS levels &gt; 0 it also pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state 
 (either waiting for a <b><var>PUBACK</var></b> or <b><var>PUBREC</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageStoreId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageStoreId
	If $Length(pMessageStoreId, ":") > 1 {
		Set msgid = $Piece(pMessageStoreId, ":", 1)
		Set dup = (''$Piece(pMessageStoreId, ":", 2))
	}
	Set message = ##class(Net.MQTT.MessageStore).%OpenId(msgid, -1, .tSC)
	Set:$$$ISOK(tSC) tSC = ..SendPUBLISH(message, dup)
	If $$$ISOK(tSC) {
		If message.QoSLevel = 1 {
			Set tSC = ##class(Net.MQTT.Aux.MessageStatus).AcknowledgeMessageOut(..ClientId, message.MessageId)
		}
		ElseIf message.QoSLevel = 2 {
			Set tSC = ##class(Net.MQTT.Aux.MessageStatus).ReceiveMessageOut(..ClientId, message.MessageId)
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBACK">
<Description><![CDATA[
Sends a <b><var>PUBACK</var></b> message to the MQTT broker for an incoming, QoS Level 1 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Identifier.</p>
<p>This is the end of the message flow of the incoming message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBACK(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).DoneMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBREC">
<Description><![CDATA[
Sends a <b><var>PUBREC</var></b> message to the MQTT broker for an incoming, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Identifier.</p>
<p>It also pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state (waiting for a <b><var>PUBREL</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBREC(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).ReleaseMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBREL">
<Description><![CDATA[
Sends a <b><var>PUBREL</var></b> message to the MQTT broker for an outgoing, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Identifier.
 If it contains a colon, this is a repeated attempt, because no acknowledge has been received for the original <b><var>PUBLISH</var></b> message
 from the broker within the defined timout period.</p>
<p>It also pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state (waiting for a <b><var>PUBCOMP</var></b> message).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set dup = 0
	Set msgid = pMessageId
	If $Length(pMessageId, ":") > 1 {
		Set msgid = $Piece(pMessageId, ":", 1)
		Set dup = (''$Piece(pMessageId, ":", 2))
	}
	Set tSC = ..SendPUBREL(msgid, dup)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).CompleteMessageOut(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="DoPUBCOMP">
<Description><![CDATA[
Sends a <b><var>PUBCOMP</var></b> message to the MQTT broker for an incoming, QoS Level 2 message. 
<p>The <property>ContextId</property> of the corresponding <class>Net.MQTT.Aux.TaskList</class> object is a Message Identifier.</p>
<p>This is the end of the message flow of the incoming message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pTaskId:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..SendPUBCOMP(pMessageId)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).DoneMessageIn(..ClientId, pMessageId)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendCONNECT">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>CONNECT</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pUsername = "" {
		Set pPassword = ""
	}
	Set will = ($IsObject(..LastWill) && (..LastWill.Topic '= "") && (..LastWill.Content '= ""))
	
	Set varhdr = $Char($Select(..CleanSession: $$$MQTTCleanSession, 1: 0)
		+ $Select(will: $$$MQTTWillFlag, 1: 0)
		+ $Select((will && ..LastWill.QoSLevel = 1): $$$MQTTWillQoS1, (will && ..LastWill.QoSLevel = 2): $$$MQTTWillQoS2, 1: 0)
		+ $Select((will && ..LastWill.Retain): $$$MQTTWillRetain, 1: 0)
		+ $Select(pUsername '= "": $$$MQTTUsernameFlag, 1: 0)
		+ $Select(pPassword '= "": $$$MQTTPasswordFlag, 1: 0)
	)
	
	Set varhdr	= ..GetProtocolName() _ ..GetProtocolVersion() _ varhdr _ $$$MQTTEncodeNumber(..KeepAliveInterval)
	Set payload	= ..GetUTFString(..ClientId)
	If will {
		Set payload = payload _ ..GetUTFString(..LastWill.Topic) _ ..GetUTFString(..LastWill.Content)
	}
	If pUsername '= "" {
		Set payload = payload _ ..GetUTFString(pUsername)
		If pPassword '= "" {
			Set payload = payload _ ..GetUTFString(pPassword)
		}
	}
	
	Quit ..PackSendMsg(varhdr_payload, $$$MQTTCONNECT)
]]></Implementation>
</Method>

<Method name="SendDISCONNECT">
<Description><![CDATA[
Creates a <b><var>DISCONNECT</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit ..PackSendMsg("", $$$MQTTDISCONNECT)
]]></Implementation>
</Method>

<Method name="SendPINGREQ">
<Description><![CDATA[
Creates a <b><var>PINGREQ</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..PackSendMsg("", $$$MQTTPINGREQ)
	Set:$$$ISOK(tSC) ..lastPing = $ZDateTime($ZTimeStamp, 3, 1)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendSUBSCRIBE">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>SUBSCRIBE</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pTopics:%ListOfObjects,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim topic As Net.MQTT.Message

	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set payload = "", key = ""
	While 1 {
		Set topic = pTopics.GetNext(.key) Quit:(key = "")
		Set payload = payload _ ..GetUTFString(topic.Topic) _ $Char($Case(topic.QoSLevel, 2: $$$MQTTSubQoS2, 1: $$$MQTTSubQoS1, : 0))
	}
	
	Set tSC = ..PackSendMsg(varhdr_payload, $$$MQTTSUBSCRIBE, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendUNSUBSCRIBE">
<Description><![CDATA[
Creates the variable header and payload of an <b><var>UNSUBSCRIBE</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pTopics:%ListOfObjects,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim topic As Net.MQTT.Message

	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set payload = "", key = ""
	While 1 {
		Set topic = pTopics.GetNext(.key) Quit:(key = "")
		Set payload = payload _ ..GetUTFString(topic.Topic)
	}
	
	Set tSC = ..PackSendMsg(varhdr_payload, $$$MQTTUNSUBSCRIBE, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBLISH">
<Description><![CDATA[
Creates the variable header and payload of a <b><var>PUBLISH</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessage:Net.MQTT.MessageStore,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = ..GetUTFString(pMessage.Topic) _ $Select(pMessage.QoSLevel > 0: $$$MQTTEncodeNumber(+pMessage.MessageId), 1: "")
	
	Set tSC = ..PackSendMsg(varhdr_pMessage.Content, $$$MQTTPUBLISH, pDup, pMessage.QoSLevel, pMessage.Retain)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBACK">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBACK</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBACK)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBREC">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBREC</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBREC)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBREL">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBREL</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer,pDup:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBREL, pDup, 1)
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendPUBCOMP">
<Description><![CDATA[
Creates the variable header of a <b><var>PUBCOMP</var></b> message and sends the package to the MQTT broker.]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set varhdr = $$$MQTTEncodeNumber(+pMessageId)
	
	Set tSC = ..PackSendMsg(varhdr, $$$MQTTPUBCOMP)
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvCONNACK">
<Description><![CDATA[
Evaluates a <b><var>CONNACK</var></b> message, received from the MQTT Broker and signals the initiator (<class>Net.MQTT.Client</class>)
 via the <class>%SYSTEM.Event</class> API about the success or failure of the connection attempt.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set ret = ""
	If $Length(pContent) '= 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid CONNACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length: " _ $Length(pContent) _ " <> 2)")
	}
	Else {
		Set ret = +$Ascii($Extract(pContent, 2))
		If ret = 1 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (unacceptable protocol version)") }
		ElseIf ret = 2 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (identifier rejected)") }
		ElseIf ret = 3 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (server unavailable)") }
		ElseIf ret = 4 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (bad username or password)") }
		ElseIf ret = 5 { Set tSC = $$$ERROR($$$GeneralError, "Connection to <" _ ..Host _ ":" _ ..Port _ "> failed (not authorized)") }
	}
	
	Do $System.Event.Signal("^MQTT.Connect(""" _ ..connectionId _ """)", $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPINGRESP">
<Description><![CDATA[
Evaluates a <b><var>PINGRESP</var></b> message, received from the MQTT Broker and clears the <property>lastPing</property> property,
 so the Agent can know that the broker is still responsive and the connection is successfully kept alive.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If pContent '= "" {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid PINGRESP message has arrived from <" _ ..Host _ ":" _ ..Port _ ">")
	}
	Else {
		Set ..lastPing = ""
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvUNSUBACK">
<Description><![CDATA[
Evaluates an <b><var>UNSUBACK</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously sent <b><var>UNSUBSCRIBE</var></b> message.]]></Description>
<Internal>1</Internal>
<CodeMode>expression</CodeMode>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RecvAcknowledge("UNSUBACK", pDup, pQoS, pRetain, pContent)
]]></Implementation>
</Method>

<Method name="RecvPUBACK">
<Description><![CDATA[
Evaluates a <b><var>PUBACK</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 1 message.
<p>This is the end of the message flow of the outgoing message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBACK", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).DoneMessageOut(..ClientId, msgid)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBREC">
<Description><![CDATA[
Evaluates a <b><var>PUBREC</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 2 message.
<p>It also pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state (a <b><var>PUBREL</var></b> message has to be sent).</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBREC", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).ReleaseMessageOut(..ClientId, msgid)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBREL">
<Description><![CDATA[
Evaluates a <b><var>PUBREL</var></b> message, received from the MQTT Broker.
<p>It pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state (a <b><var>PUBCOMP</var></b> message has to be sent),
 and cretes a new task (<class>Net.MQTT.Aux.TaskList</class>) to complete the next step of the QoS Level 2 message flow.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBREL", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).CompleteMessageIn(..ClientId, msgid)
	Set:$$$ISOK(tSC) taskid = ##class(Net.MQTT.Aux.TaskList).CreateNewTask(..connectionId, msgid, "PUBCOMP", .tSC)

	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBCOMP">
<Description><![CDATA[
Evaluates a <b><var>PUBCOMP</var></b> message, received from the MQTT Broker and 
 signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of a previously published QoS Level 2 message.
<p>This is the end of the message flow of the outgoing message.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..RecvAcknowledge("PUBCOMP", pDup, pQoS, pRetain, pContent, .msgid)
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).DoneMessageOut(..ClientId, msgid)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvAcknowledge">
<Description><![CDATA[
Generic method for evaluating an acknowledge type message and signaling the appropriate process via the <class>%SYSTEM.Event</class> API
 waiting for this acknowledge.]]></Description>
<Internal>1</Internal>
<FormalSpec>pType:%String,pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String,*pMsgId:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If $Length(pContent) '= 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid " _ pType _ " message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length: " _ $Length(pContent) _ " <> 2)")
	}
	Else {
		Set pMsgId = $$$MQTTDecodeNumber(pContent)
		Do ##class(Net.MQTT.Aux.TaskList).SignalAck(..connectionId, pMsgId, pType, $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvSUBACK">
<Description><![CDATA[
Evaluates a <b><var>SUBACK</var></b> message, received from the MQTT Broker,
 stores the QoS levels granted by the broker on the various items of the subscription message (see: <class>Net.MQTT.Aux.Subscription</class>)
 and signals the <class>Net.MQTT.Client</class> waiting for this acknowledge of the previously sent <b><var>SUBSCRIBE</var></b> message.]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	If $Length(pContent) < 2 {
		Set tSC = $$$ERROR($$$GeneralError, "Invalid SUBACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (length < 2)")
	}
	Else {
		Set msgid = $$$MQTTDecodeNumber($Extract(pContent, 1, 2))
		Set cnt = ##class(Net.MQTT.Aux.Subscription).GetTopicCount(..ClientId, msgid, .tSC)
		If $$$ISOK(tSC) {
			If $Length(pContent) '= (2 + cnt) {
				Set tSC = $$$ERROR($$$GeneralError, "Invalid SUBACK message has arrived from <" _ ..Host _ ":" _ ..Port _ "> (# of topics)")
			}
			Else {
				For i = 1: 1: cnt {
					Set tSC = ##class(Net.MQTT.Aux.Subscription).AckTopic(..ClientId, msgid, i, $Case($Ascii($Extract(pContent, 2 + i)), $$$MQTTSubQoS2: 2, $$$MQTTSubQoS1: 1, : 0))
					Quit:$$$ISERR(tSC)
				}
			}
		}
		Do ##class(Net.MQTT.Aux.TaskList).SignalAck(..connectionId, msgid, "SUBACK", $Select($$$ISOK(tSC): "", 1: $System.Status.GetErrorText(tSC)))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecvPUBLISH">
<Description><![CDATA[
Evaluates a <b><var>PUBLISH</var></b> message, received from the MQTT Broker and
 stores the incoming message as a <class>Net.MQTT.MessageStore</class> object.
<p>If the QoS Level > 0, it also pushes the <class>Net.MQTT.Aux.MessageStatus</class> to the next state 
 (either a <b><var>PUBACK</var></b> or <b><var>PUBREC</var></b> message has to be sent),
 and cretes a new task (<class>Net.MQTT.Aux.TaskList</class>) to complete the next step of the message flow.</p>]]></Description>
<Internal>1</Internal>
<FormalSpec>pDup:%Boolean,pQoS:%Integer,pRetain:%Boolean,pContent:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set topicL = $$$MQTTDecodeNumber($Extract(pContent, 1, 2))
	Set topic = $Extract(pContent, 3, 2 + topicL)
	Set pos = 3 + topicL
	If pQoS > 0 {
		Set msgid = $$$MQTTDecodeNumber($Extract(pContent, pos, pos + 1))
		Set pos = pos + 2
	}
	Else {
		Set msgid = ""
	}

	TStart
	Set tSC = ##class(Net.MQTT.Aux.MessageStatus).%LockExtent(0)
	TRY {
		Set dup = $Select(pQoS > 0: pDup, 1: 0)
		If dup {
			Set dup = ##class(Net.MQTT.Aux.MessageStatus).IsRegisteredMessageIn(..ClientId, msgid)
		}
		If 'dup {
			If pQoS > 0 {
				Set tSC = ##class(Net.MQTT.Aux.MessageStatus).RegisterMessageIn(..ClientId, msgid, pQoS)
			}
			If $$$ISOK(tSC) {
				Set msg				= ##class(Net.MQTT.MessageStore).%New()
				Set msg.ClientId	= ..ClientId
				Set msg.Direction	= "I"
				Set msg.MessageId	= msgid
				Set msg.QoSLevel	= pQoS
				Set msg.Retain		= pRetain
				Set msg.Topic		= topic
				Set msg.Content		= $Extract(pContent, pos, *)
				Set tSC = msg.%Save()
			}
			If $$$ISOK(tSC) && (pQoS > 0) {
				Set taskid = ##class(Net.MQTT.Aux.TaskList).CreateNewTask(..connectionId, msgid, $Case(pQoS, 2: "PUBREC", : "PUBACK"), .tSC)
			}
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ##class(Net.MQTT.Aux.MessageStatus).%UnlockExtent()
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
		
	Quit tSC
]]></Implementation>
</Method>

<Method name="CloseDev">
<Internal>1</Internal>
<Private>1</Private>
<Implementation><![CDATA[
	If ..connected {
		$$$MQTTTraceINF("Agent for " _ ..ClientId _ " to <" _ ..Host _ ":" _ ..Port _ "> is stopping TCP connection")
		Close ..device
		Use ..saveIODev
		Set ..connected = 0, ..device = ""
	}
]]></Implementation>
</Method>

<Method name="PackSendMsg">
<Internal>1</Internal>
<FormalSpec>pMessage:%String,pMessageType:%Integer,pDup:%Boolean=0,pQoS:%Integer=0,pRetain:%Boolean=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set header = $Char(pMessageType 
		+ $Select(pDup: $$$MQTTDup, 1: 0) 
		+ $Select(pRetain: $$$MQTTRetain, 1: 0) 
		+ $Case(pQoS, 2: $$$MQTTQoS2, 1: $$$MQTTQoS1, : 0)
	)

	Set lng = $Length(pMessage)
	While 1 {
		Set nxt = lng # 128
		Set lng = lng \ 128
		If lng > 0 {
			Set nxt = nxt + 128
		}
		Set header = header _ $Char(nxt)
		Quit:(lng '> 0)
	}

	Set msg = header_pMessage
	Write msg, !
	Set ..lastMessage = $ZDateTime($ZTimeStamp, 3, 1)
	$$$MQTTTraceOUT($$$MQTTMsgType(pMessageType), msg) 
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetMessageType">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set type = 0
	For i = 5: 1: 8 {
		Set type = type + ($Bit(a, i) * (2 ** (i - 1)))
	}
	 
	Quit type
]]></Implementation>
</Method>

<Method name="IsDuplicate">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set b = $Factor($$$MQTTDup)
	Quit $BitLogic(a & b) = b
]]></Implementation>
</Method>

<Method name="GetQoSLevel">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set a  = $Factor($Ascii(pHeader))
	Set q1 = $Factor($$$MQTTQoS1)
	Set q2 = $Factor($$$MQTTQoS2)
	Quit $Select($BitLogic(a & q2) = q2: 2, $BitLogic(a & q1) = q1: 1, 1: 0)
]]></Implementation>
</Method>

<Method name="IsRetain">
<ClassMethod>1</ClassMethod>
<FormalSpec>pHeader:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set a = $Factor($Ascii(pHeader))
	Set b = $Factor($$$MQTTRetain)
	Quit $BitLogic(a & b) = b
]]></Implementation>
</Method>

<Method name="GetUTFString">
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set tString = $ZCVT(pString, "O", ..transTable)
	Set tLen = $L(tString)
	
	Quit $$$MQTTEncodeNumber(tLen) _ tString
]]></Implementation>
</Method>
</Class>


<Class name="Net.MQTT.Aux.MessageCounter">
<Description><![CDATA[
Auxiliary class to provide unique Message Identifiers for in-flight messages of a specific client connection.
<p>MQTT standard only specifies that Message Identifiers must be unique among the currently in-flight messages.
This class helps to initialize a new message sequence for each Client (<class>Net.MQTT.Client</class>) / Agent (<class>Net.MQTT.Agent</class>) pairs,
 based on the <property>ClientId</property>. This also means that <property>ClientId</property> must be unique among parallel
 Client instances currently running in the same database.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,53150.105508</TimeChanged>
<TimeCreated>64070,61478.847771</TimeCreated>

<Index name="ClientKey">
<IdKey>1</IdKey>
<PrimaryKey>1</PrimaryKey>
<Properties>ClientId</Properties>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="LastMessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="CreateCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances to create a new Message Identifier sequence.
for a <property>ClientId</property> (which must be unqique among the currently running Clients). ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	TRY {
		If ..%ExistsId(pClientId) {
			Set tSC = $$$ERROR($$$GeneralError, "Client ID ('" _ pClientId _ "') is already used")
		}
		Else {
			Set obj = ..%New()
			Set obj.ClientId = pClientId
			Set tSC = obj.%Save()
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	Quit tSC
]]></Implementation>
</Method>

<Method name="NextMessageId">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Returns the next available Message Idenfier for a specific <property>ClientId</property>.</p>
<p>Currently MQTT Message Identifiers must fall between 1 and 65535. After 65535 the counter simply turns into 1 again,
simply assuming that this cannot lead to a collision among current in-flight messages.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pClientId, 4, .pSC)
	If $$$ISOK(pSC) {
		Set obj.LastMessageId = $Case(obj.LastMessageId, 65535: 1, : obj.LastMessageId + 1)
		Set pSC = obj.%Save()
	}
	Quit $Select($$$ISOK(pSC): obj.LastMessageId, 1: "")
]]></Implementation>
</Method>

<Method name="DropCounter">
<Description><![CDATA[
Used internally, by <class>Net.MQTT.Client</class> instances.
<p>Deletes the corresponding counter, when a Client is about to stop (more specifically: when its <class>Net.MQTT.Agent</class> is stopped).</p>]]></Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pClientId, 4)
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.MessageCounterD</DataLocation>
<DefaultData>MessageCounterDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.MessageCounterD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.MessageCounterI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.MessageCounterS</StreamLocation>
<Data name="MessageCounterDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>LastMessageId</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.MessageStatus">
<Description><![CDATA[
Auxiliary class used only internally to keep track of QoS level 1-2 message, while they're waiting for completion of the communication.
<class>This class is used only internally by the <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> classes.
<p>Messages are delete from this class, as soon as the corresponding message flow is completed.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,54377.648006</TimeChanged>
<TimeCreated>64050,79985.782311</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,Direction,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="Direction">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",I,O"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Status">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP,DONE"/>
</Property>

<Method name="RegisterMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String,pQoSLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "I", $Case(pQoSLevel, 2: "PUBREC", : "PUBACK"))
]]></Implementation>
</Method>

<Method name="IsRegisteredMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..ClientKeyExists(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="ReleaseMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "I", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageIn">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "I", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..RegisterNew(pClientId, pMessageId, "O", "PUBLISH")
]]></Implementation>
</Method>

<Method name="AcknowledgeMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBACK")
]]></Implementation>
</Method>

<Method name="ReceiveMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREC")
]]></Implementation>
</Method>

<Method name="ReleaseMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBREL")
]]></Implementation>
</Method>

<Method name="CompleteMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Update(pClientId, "O", pMessageId, "PUBCOMP")
]]></Implementation>
</Method>

<Method name="DoneMessageOut">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pClientId:%String,pMessageId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..Done(pClientId, "O", pMessageId)
]]></Implementation>
</Method>

<Method name="RegisterNew">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pDirection:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set msgid = ""
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }
	
	TRY {
		Set obj = ..%New()
		Set obj.ClientId = pClientId
		Set obj.Direction = pDirection
		Set obj.MessageId = pMessageId
		Set obj.Status = pStatus
		Set tSC = obj.%Save()
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Update">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String,pStatus:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set obj = ..ClientKeyOpen(pClientId, pDirection, pMessageId, 0, .tSC)
		If $$$ISOK(tSC) {
			Set obj.Status = pStatus
			Set tSC = obj.%Save()
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") cannot be updated for " _ pClientId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Done">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pDirection:%String,pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%LockExtent(0)
	If $$$ISERR(tSC) { Quit tSC }

	TRY {
		Set exists = ..ClientKeyExists(pClientId, pDirection, pMessageId, .id)
		If exists {
			Set tSC = ..%DeleteId(id, 0)
		}
		Else {
			Set tSC = $$$ERROR($$$GeneralError, "Message ID (" _ pDirection _ "," _ pMessageId _ ") does not currently exists for " _ pClientId)
		}
	}
	CATCH ex {
		Set pSC = ex.AsStatus()
	}
	Do ..%UnlockExtent()
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.MessageStatusD</DataLocation>
<DefaultData>MessageStatusDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.MessageStatusD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.MessageStatusI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.MessageStatusS</StreamLocation>
<Data name="MessageStatusDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>MessageId</Value>
</Value>
<Value name="4">
<Value>Status</Value>
</Value>
<Value name="5">
<Value>Direction</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.Subscription">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class> to keep track of 
<b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> message contents.
<p>These messages must have a unique Message Idenfier among current in-flight messages (per Client), 
 therefore all instances are dropped as soon as the corresponding message flow is completed.</p>]]></Description>
<IncludeCode>MQTTOptions</IncludeCode>
<Super>%Persistent</Super>
<TimeChanged>64072,53677.046645</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="ClientKey">
<Properties>ClientId,MessageId</Properties>
<Unique>1</Unique>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="MAXVAL" value="65653"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Topics">
<Type>Net.MQTT.Aux.SubscriptionTopic</Type>
<Cardinality>children</Cardinality>
<Inverse>Subscription</Inverse>
<Relationship>1</Relationship>
</Property>

<Method name="CreateSubscription">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>Net.MQTT.Aux.Subscription</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ClientId = pClientId
	Set obj.MessageId = pMessageId
	Set pSC = obj.%Save()
	
	Quit $Select($$$ISOK(pSC): obj, 1: "")
]]></Implementation>
</Method>

<Method name="DropSubscription">
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[..%DeleteId(pId)
]]></Implementation>
</Method>

<Method name="AddTopic">
<FormalSpec>pTopic:Net.MQTT.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ##class(Net.MQTT.Aux.SubscriptionTopic).%New()
	Set obj.Topic = pTopic.Topic
	Set obj.QoSLevel = pTopic.QoSLevel
	Set tSC = ..Topics.Insert(obj)
	Set:$$$ISOK(tSC) tSC = ..%Save()
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetTopicCount">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, 0, .pSC)
	If $$$ISOK(pSC) {
		Set ret = obj.Topics.Count()
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="GetTopicList">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pClientId:%String,pMessageId:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<ReturnTypeParams>ELEMENTTYPE="Net.MQTT.Message"</ReturnTypeParams>
<Implementation><![CDATA[
 	Set ret = ##class(%ListOfObjects).%New()
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .pSC)
	If $$$ISOK(pSC) {
		For i = 1: 1: obj.Topics.Count() {
			Set next = obj.Topics.GetAt(i)
			
			Set msg = ##class(Net.MQTT.Message).%New()
			Set msg.Topic = next.Topic
			Set msg.QoSLevel = next.QoSLevel
			Set pSC = ret.Insert(msg)
			Quit:$$$ISERR(pSC)
		}
	}
 	
	Quit $Select($$$ISOK(pSC): ret, 1: "")
]]></Implementation>
</Method>

<Method name="AckTopic">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String,pMessageId:%String,pTopicNr:%Integer,pGrantedQoS:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..ClientKeyOpen(pClientId, pMessageId, -1, .tSC)
	If $$$ISOK(tSC) {
		If (pTopicNr < 1) || (pTopicNr > obj.Topics.Count()) {
			Set tSC = $$$ERROR($$$GeneralError, "Inavlid topic number (" _ pTopicNr _ " is not between 1 and " _ obj.Topics.Count() _ ")")
		}
		Else {
			Set topic = obj.Topics.GetAt(pTopicNr)
			Set topic.GrantedQoS = pGrantedQoS
			Set tSC = topic.%Save()
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="RetrieveAck">
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..%Reload()
	If $$$ISOK(tSC) {
		If pTopics.Count() '= ..Topics.Count() {
			Set tSC = $$$ERROR($$$GeneralError, "Topic count mismatch (" _ pTopics.Count() _ " <> " _ ..Topics.Count() _ ")")
		}
		Else {
			For i = 1: 1: pTopics.Count() {
				Set pTopics.GetAt(i).GrantedQoS = ..Topics.GetAt(i).GrantedQoS
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.SubscriptionD</DataLocation>
<DefaultData>SubscriptionDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.SubscriptionD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.SubscriptionI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.SubscriptionS</StreamLocation>
<Data name="SubscriptionDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>MessageId</Value>
</Value>
<Value name="4">
<Value>TopicNr</Value>
</Value>
<Value name="5">
<Value>Topic</Value>
</Value>
<Value name="6">
<Value>QoSLevel</Value>
</Value>
<Value name="7">
<Value>GrantedQoS</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.SubscriptionTopic">
<Description><![CDATA[
Auxiliary class is used only internally by a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.
<p>Provides the topic list, which the primary content of <b><var>SUBSCRIBE</var></b> and <b><var>UNSUBSCRIBE</var></b> messages.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,54267.846928</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="TopicKey">
<Properties>Subscription,Topic</Properties>
<Unique>1</Unique>
</Index>

<Property name="Subscription">
<Type>Net.MQTT.Aux.Subscription</Type>
<Cardinality>parent</Cardinality>
<Inverse>Topics</Inverse>
<Relationship>1</Relationship>
</Property>

<Property name="Topic">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Type>%Integer</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.Subscriptio1311D</DataLocation>
<DefaultData>SubscriptionTopicDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.Subscriptio1311D</IdLocation>
<IndexLocation>^Net.MQTT.Aux.Subscriptio1311I</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.Subscriptio1311S</StreamLocation>
<Data name="SubscriptionTopicDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Subscription</Value>
</Value>
<Value name="3">
<Value>Topic</Value>
</Value>
<Value name="4">
<Value>QoSLevel</Value>
</Value>
<Value name="5">
<Value>GrantedQoS</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Aux.TaskList">
<Description><![CDATA[
Auxiliary class is used only internally, which proides an event-drivn interface for a <class>Net.MQTT.Client</class> and its <class>Net.MQTT.Agent</class>.]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64073,2824.483814</TimeChanged>
<TimeCreated>64051,66904.675697</TimeCreated>

<Property name="ConnectionId">
<Description><![CDATA[
<property>connectionId</property> property of the corresponding <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> objects.]]></Description>
<Type>%String</Type>
<Required>1</Required>
</Property>

<Property name="ContextId">
<Description>
Task-dependent context identifier. The cretor and processor of the task must agree on the meaning of this string. </Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Action">
<Description>
List of actions, which require an event-driven interface.</Description>
<Type>%String</Type>
<Required>1</Required>
<Parameter name="VALUELIST" value=",DISCONNECT,SUBSCRIBE,UNSUBSCRIBE,PUBLISH,PUBACK,PUBREC,PUBREL,PUBCOMP"/>
</Property>

<Property name="Status">
<Description><![CDATA[
Current status of the task:<ul>
<li><b><var>0</var></b> - <b><var>Pending</var></b>, waiting for being processed.</li>
<li><b><var>1</var></b> - <b><var>In progress</var></b>, the <class>Net.MQTT.Agent</class> already picked up the task.</li>
<li><b><var>2</var></b> - <b><var>Done</var></b>, and kept for debugging purposes.</li>
</ul>]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
<Required>1</Required>
<Parameter name="MAXVAL" value="2"/>
<Parameter name="MINVAL" value="0"/>
</Property>

<Method name="WaitAck">
<Description><![CDATA[
Called when a particular message (identified by <var>pMessageId</var>) of a client connection is waiting for an event.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pTimeout:%Integer=-1</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Set ret = $System.Event.WaitMsg("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pTimeout)
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalAck">
<Description><![CDATA[
Called to trigger an event of a particular message (identified by <var>pMessageId</var>) of a client connection.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pMessageId:%String,pStatus:%String,pContent:%String=""</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Create("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)")
	Quit $System.Event.Signal("^MQTT.Message(""" _ pConnectionId _ """,""" _ pMessageId _ """,""" _ pStatus _ """)", pContent)
]]></Implementation>
</Method>

<Method name="WaitTask">
<Description><![CDATA[
Creates a task and waits until it will be completed.
<p>The <class>%SYSTEM.Event</class> API is used to implement this, for detailed explanation of the return value, see that class documentation!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,pTimeout:%Integer=-1,&pSC:%Status]]></FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
	Set ret = ""
	Set taskId = ..CreateNewTask(pConnectionId, pContextId, pAction, .pSC)
	If $$$ISOK(pSC) {
		Do $System.Event.Create("^MQTT.Task(""" _ pConnectionId _ """,""" _ taskId _ """)")
		Set ret = $System.Event.WaitMsg("^MQTT.Task(""" _ pConnectionId _ """,""" _taskId _ """)", pTimeout)
	}
	
	Quit ret
]]></Implementation>
</Method>

<Method name="SignalTask">
<Description><![CDATA[
Signals the completion of a task.
<p><var>pStatusCode</p> is the return status of the method, which processed the task.</p>
<p><var>pDebugMode</p> shows, whether the <class>Net.MQTT.Aux.TaskList</class> object has to be kept for debugging purposes,
 or can be deleted.</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,pTaskId:%String,pStatusCode:%Status,pDebugMode:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do $System.Event.Signal("^MQTT.Task(""" _ pConnectionId _ """,""" _ pTaskId _ """)", $Select($$$ISOK(pStatusCode): "", 1: $System.Status.GetErrorText(pStatusCode)))
	Set tSC = ..CompleteTask(pTaskId, pDebugMode)
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CreateNewTask">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pConnectionId:%String,pContextId:%String,pAction:%String,&pSC:%Status]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%New()
	Set obj.ConnectionId = pConnectionId
	Set obj.ContextId = pContextId
	Set obj.Action = pAction
	Set pSC = obj.%Save()
	Quit $Select($$$ISOK(pSC): obj.%Id(), 1: "")
]]></Implementation>
</Method>

<Method name="AcquireNext">
<ClassMethod>1</ClassMethod>
<FormalSpec>pConnectionId:%String,*pTaskId:%String,*pContextId:%String,*pAction:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Set (pTaskId, pContextId, pAction) = ""
	Lock +^Net.MQTT.Aux.TaskListD:5 Quit:('$Test) $$$ERROR($$$GeneralError, "Task table lock failed")
	TRY {
		&sql(SELECT TOP 1 
			ID, ContextId, Action 
		INTO 
			:pTaskId, :pContextId, :pAction
		FROM
			Net_MQTT_Aux.TaskList
		WHERE
			ConnectionId = :pConnectionId AND Status = 0
		)
		If $Get(SQLCODE, 0) {
			If (SQLCODE '= 100) {
				Set tSC = $$$ERROR($$$GeneralError, "Task table query failed (" _ SQLCODE _ ")")
			}
		}
		Else {
			Set tSC = ..AcquireTask(pTaskId)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	Lock -^Net.MQTT.Aux.TaskListD
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="AcquireTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set obj = ..%OpenId(pTaskId, 4)
	If $IsObject(obj) {
		Set obj.Status = 1
		Set tSC = obj.%Save()
	}
	Else {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="CompleteTask">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTaskId:%String,pKeepIt:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK, found = 0
	If pKeepIt {
		Set obj = ..%OpenId(pTaskId, 4)
		If $IsObject(obj) {
			Set found = 1
			Set obj.Status = 2
			Set tSC = obj.%Save()
		}
	}
	Else {
		Set found = $$$ISOK(..%DeleteId(pTaskId, 4))
	}

	If 'found {
		Set tSC = $$$ERROR($$$GeneralError, "Task cannot be found (id = " _ pTaskId _ ")")
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.Aux.TaskListD</DataLocation>
<DefaultData>TaskListDefaultData</DefaultData>
<IdLocation>^Net.MQTT.Aux.TaskListD</IdLocation>
<IndexLocation>^Net.MQTT.Aux.TaskListI</IndexLocation>
<StreamLocation>^Net.MQTT.Aux.TaskListS</StreamLocation>
<Data name="TaskListDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ConnectionId</Value>
</Value>
<Value name="3">
<Value>ContextId</Value>
</Value>
<Value name="4">
<Value>Action</Value>
</Value>
<Value name="5">
<Value>Status</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Net.MQTT.Client">
<Description><![CDATA[
The main class and public API for the <i>Cach Object Script</i> MQTT Client sample implementation (version: 0.9).

<p>For more information regarding the MQTT protocol visit the <a href="http://mqtt.org">MQTT Org.</a> website,
 or examine the <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html">OASIS</a> standard specification.</p>

<p>Fully functional to demonstrate all kind of MQTT Client activities, but not a fully-featured client.</p>

<p>There are a few known (and maybe some unknown) limitations:<ul>
<li>It's not prepared for SSL / TLS communication.</li>
<li>TCP/IP based only, cannot be used with web-socket based MQTT Brokers.</li>
<li>Communication of the <class>Net.MQTT.Client</class> and background <class>Net.MQTT.Agent</class> instances is limited to the
 tasks to be done / completed. This could be enriched with for example status information of the Agent, which would make
 it easier to monitor the background job from the Client interface and check its health status in certain scenarios.</li>
<li>Incoming and outgoing messages are simply logged into the <class>Net.MQTT.MessageStore</class> class. No any checks for
 duplicate messages are done (when an incoming message is repeated by the Broker, due to a lost acknowledge).</li>
<li>For incoming QoS Level 2 messages no retry mechanism is implemented: if no <b><var>PUBREL</b></var> message would arrive
 for the <b><var>PUBREC</b></var> acknowledge, the Agent will simply wait for it endless and the message remains in the 
 <class>Net.MQTT.Aux.MessageStatus</class>, registered with a <var>waiting for PUBREL</var> status.</li>
</ul></p>
<p>Questions, bug reports, recommendations are highly welcome to my <a href="mailto:Attila.Toth@InterSystems.com">Inbox</a>.</p>]]></Description>
<IncludeCode>MQTTOptions</IncludeCode>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>64073,8769.106247</TimeChanged>
<TimeCreated>64041,57924.914604</TimeCreated>

<Property name="Host">
<Description>
Host name of the MQTT Broker.</Description>
<Type>%String</Type>
<InitialExpression>"localhost"</InitialExpression>
</Property>

<Property name="Port">
<Description>
Port number of the MQTT Broker.</Description>
<Type>%String</Type>
<InitialExpression>1883</InitialExpression>
</Property>

<Property name="ConnectTimeout">
<Description>
Timeout (in seconds) of building the TCP Connection to the MQTT Broker.</Description>
<Type>%Integer</Type>
<InitialExpression>10</InitialExpression>
</Property>

<Property name="ReadTimeout">
<Description><![CDATA[
Generic default timeout for all kinds of action when either an incoming TCP communication is expected,
 or the Client interface has to wait for the <class>Net.MQTT.Agent</class> to complete a task.]]></Description>
<Type>%Integer</Type>
<InitialExpression>10</InitialExpression>
</Property>

<Property name="KeepAliveInterval">
<Description><![CDATA[
The MQTT Broker may close the connection to the Client, if no requests are received within this interval (in seconds).
<p>It's the responsibility of the <class>Net.MQTT.Agent</class> to send a PING request at least in each intervals.</p>]]></Description>
<Type>%Integer</Type>
<InitialExpression>60</InitialExpression>
</Property>

<Property name="ClientId">
<Description><![CDATA[
Identifies the Client at the MQTT Broker.
<p>This implementation is restricted multiple places to use unique Client IDs among the co-existing <class>Net.MQTT.Client</class>
 instances within the same database. This restriction is acceptable, as the MQTT Brokers may reject multiple TCP connections 
 with the same Client ID.</p>]]></Description>
<Type>%String</Type>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="CleanSession">
<Description><![CDATA[
Sent with the <b><var>CONNECT</b></var> message to the MQTT Broker.
<p>For details see the MQTT standard specification.</p>]]></Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="LastWill">
<Description>
This object contains details of the "Last will and testament" of this Client - the message to be sent to subscribed Clients
 from the MQTT Broker in case, when the Broker's connection to this Client would be closed / lost.</Description>
<Type>Net.MQTT.Message</Type>
</Property>

<Property name="Retry">
<Description><![CDATA[
Some QoS Level 1 and 2 messages (<b><var>PUBLISH</b></var>, <b><var>PUBREL</b></var>, <b><var>SUBSCRIBE</b></var>, <b><var>UNSUBSCIBE</b></var>)
 might be re-sent by the Client if no appropriate acknowledge can be received from the MQTT Broker within the specified timout intervals.
<br/>This property controls the maximum number of repeated attempts.]]></Description>
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="RetryInterval">
<Description><![CDATA[
Some QoS Level 1 and 2 messages (<b><var>PUBLISH</b></var>, <b><var>PUBREL</b></var>, <b><var>SUBSCRIBE</b></var>, <b><var>UNSUBSCIBE</b></var>)
 might be re-sent by the Client if no appropriate acknowledge can be received from the MQTT Broker within the specified timout intervals.
<br/>This property controls the wait interval (in seconds) within each repeated attempts.]]></Description>
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="traceTarget">
<Description>
For debugging purposes this property can be set to any global variable names (e.g.: ^MQTT.Trace), 
 in which case detailed trace information is logged into the specified global about the actions taken and also
 the incoming and outgoing TCP communication.</Description>
<Type>%String</Type>
</Property>

<Property name="trace">
<Type>%Boolean</Type>
<Calculated>1</Calculated>
</Property>

<Method name="traceGet">
<CodeMode>expression</CodeMode>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[..traceTarget '= ""
]]></Implementation>
</Method>

<Property name="debugMode">
<Description><![CDATA[
For debugging purposes this property can be set to 1, in which case some originally temporary information is not deleted from
 auxiliary tables (for example: <class>Net.MQTT.Aux.TaskList</class>). ]]></Description>
<Type>%Integer</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="connectionId">
<Description><![CDATA[
This property is a unique identifier of the <class>Net.MQTT.Client</class> and the related <class>Net.MQTT.Agent</class> instance,
 and it is used in event-driven communication of the foreground Client and the background Agent processes.
<p>This is meant to be set automatically by the Client, do not set it directly!</p>]]></Description>
<Type>%String</Type>
<InitialExpression>$System.Util.CreateGUID()</InitialExpression>
</Property>

<Property name="agent">
<Description><![CDATA[
Do not manipulate this property, which should always contain the JOB id of the corresponding <class>Net.MQTT.Agent</class>.]]></Description>
<Type>%String</Type>
</Property>

<Method name="StartAgent">
<Description><![CDATA[
This is the first method to be called, in order to communicate with an MQTT Broker.
<p>Starts a <class>Net.MQTT.Agent</class> instance, which is responsible for building the TCP connection and 
 managing the communication with the broker.</p>]]></Description>
<FormalSpec>pUsername:%String="",pPassword:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has already been started")
	}
	Else {
		Set tSC = ##class(Net.MQTT.Aux.MessageCounter).CreateCounter(..ClientId)
		Set:$$$ISOK(tSC) tSC = ..XMLExportToString(.data, "root")
		If $$$ISOK(tSC) {
			Do $System.Event.Create("^MQTT.Connect(""" _ ..connectionId _ """)")
			JOB ##class(Net.MQTT.Agent).StartListening(data, pUsername, pPassword)
			Set ..agent = $ZChild
			Set ret = $System.Event.WaitMsg("^MQTT.Connect(""" _ ..connectionId _ """)", (..ConnectTimeout * 1.5))
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not connected within the timeout period")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			
			If $$$ISERR(tSC) {
				Do ..KillAgent()
			}
		}
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="StopAgent">
<Description><![CDATA[
Stops the Agent by sending <b><var>DISCONNECT</var></b> message and closing the TCP connection to the MQTT Broker.
<p>If this method completes successfully, the <class>Net.MQTT.Client</class> instance is re-usable and 
 its <method>StartAgent</method> method can be called again.</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set ret = ##class(Net.MQTT.Aux.TaskList).WaitTask(..connectionId, ..connectionId, "DISCONNECT", ..ConnectTimeout * 1.5, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not disconnected within the timeout period")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
		}
		
		Set tSC = $System.Status.AppendStatus(tSC, ..KillAgent())
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="KillAgent">
<Description><![CDATA[
Normally this meant to be used only internally by the <method>StopAgent</method> method.
<p>In some rare cases, when the Agent cannot be stopped normally (by sending a <b><var>DISCONNECT</var></b> message),
 this can still be used to terminate the Agent's background job and perform important maintenance steps.</p>]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	If ..agent '= "" {
		Set ret = ##class(%SYSTEM.Process).Terminate(..agent, 0)
		If ret '= 1 {
			Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent cannot be stopped in a clean way (status = " _ ret _ ")")
		}
		Set ..agent = ""
	}
	Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageCounter).DropCounter(..ClientId)

	// Re-initialize connection id for subsequent start of the Agent
	Set ..connectionId = $System.Util.CreateGUID()

	Quit tSC
]]></Implementation>
</Method>

<Method name="Subscribe">
<Description><![CDATA[
Sends a request to the MQTT Broker to subsribe this client for a list of topics and controls the message flow:
<blockquote>
 Sends the <b><var>SUBSCRIBE</var></b> message and if no <b><var>SUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>SUBSCRIBE</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<blockquote>
 If the acknowledge is received, the <property>GrantedQoS</property> of each elements in the <var>pTopics</var> list should contain
  the QoS Level assured by the MQTT broker for the corresponding topic. 
</blockquote>
<p>Usage example:</p>
<example>
Set tpc = ##class(Net.MQTT.Message).%New()
Set tpc.Topic = "$SYS/broker/load/bytes/#"
Set tpc.QoSLevel = 2
Set topics = ##class(%ListOfObjects).%New()
Do topics.Insert(tpc)
 
Set client = ##class(Net.MQTT.Client).%New()
Set client.Host = "test.mosquitto.org"
Set client.ClientId = "My1stMQTTClient"
Set client.traceTarget = "^MQTT.Trace"
Set sc = client.StartAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.Subscribe(.topics) If ('sc) { Do $System.OBJ.DisplayError(sc) }
If (''sc) { Set t=topics.GetAt(1) Write "Topic:'"_t.Topic_"'; Expected QoS:"_t.QoSLevel_"; Granted QoS:"_t.GrantedQoS_";", ! }
; wait a few seconds to receive some messages from the broker 
Set sc = client.Unsubscribe(.topics) If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.StopAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
ZWrite ^MQTT.Trace
</example>]]></Description>
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim sub As Net.MQTT.Aux.Subscription
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pTopics) || (pTopics.Count() < 1) {
		Quit $$$ERROR($$$GeneralError, "At least one topic must be specified to subscribe for")
	}
	
	Set msgId = ##class(Net.MQTT.Aux.MessageCounter).NextMessageId(..ClientId, .tSC)
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for SUBSCRIBE message cannot be created")
	}
	
	TStart
	TRY {
		Set key = "", cnt = 0
		Set sub = ##class(Net.MQTT.Aux.Subscription).CreateSubscription(..ClientId, msgId, .tSC)
		While $$$ISOK(tSC) {
			Set topic = pTopics.GetNext(.key) Quit:(key = "")
			Set tSC = sub.AddTopic(topic)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Aux.TaskList).WaitTask(..connectionId, msgId _ $Select(retcnt: ":" _ retcnt, 1: ""), "SUBSCRIBE", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Aux.TaskList).WaitAck(..connectionId, msgId, "SUBACK", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				ElseIf success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
				Else {
					Set tSC = sub.RetrieveAck(.pTopics)
				}
			}
		}
	}
	
	If $IsObject(sub) {
		Set subid = sub.%Id(), sub = ""
		Set tSC = $System.Status.AppendStatus(tSC, ##class(Net.MQTT.Aux.Subscription).DropSubscription(subid))
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="Unsubscribe">
<Description><![CDATA[
Sends a request to the MQTT Broker to unsubsribe this client from a list of topics and controls the message flow:
<blockquote>
 Sends the <b><var>UNSUBSCRIBE</var></b> message and if no <b><var>UNSUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>UNSUBSCRIBE</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>For usage example see the <method>Subscribe</method> method.</p>]]></Description>
<FormalSpec><![CDATA[&pTopics:%ListOfObjects(ELEMENTTYPE="Net.MQTT.Message")]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#dim sub As Net.MQTT.Aux.Subscription
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pTopics) || (pTopics.Count() < 1) {
		Quit $$$ERROR($$$GeneralError, "At least one topic must be specified to unsubscribe from")
	}
	
	Set msgId = ##class(Net.MQTT.Aux.MessageCounter).NextMessageId(..ClientId, .tSC)
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for UNSUBSCRIBE message cannot be created")
	}
	
	TStart
	TRY {
		Set key = "", cnt = 0
		Set sub = ##class(Net.MQTT.Aux.Subscription).CreateSubscription(..ClientId, msgId, .tSC)
		While $$$ISOK(tSC) {
			Set topic = pTopics.GetNext(.key) Quit:(key = "")
			Set tSC = sub.AddTopic(topic)
		}
	}
	CATCH ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISOK(tSC) { TCommit }
	Else { TRollback }
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Aux.TaskList).WaitTask(..connectionId, msgId _ $Select(retcnt: ":" _ retcnt, 1: ""), "UNSUBSCRIBE", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Aux.TaskList).WaitAck(..connectionId, msgId, "UNSUBACK", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
			}
		}
	}
	
	If $IsObject(sub) {
		Set subid = sub.%Id(), sub = ""
		Set tSC = $System.Status.AppendStatus(tSC, ##class(Net.MQTT.Aux.Subscription).DropSubscription(subid))
	}

	Quit tSC
]]></Implementation>
</Method>

<Method name="Publish">
<Description><![CDATA[
Publishes a message to the MQTT Broker and (on QoS Level > 0) controls the message flow.
<p>In case of QoS = 1</p>
<blockquote>
 Sends the <b><var>PUBLISH</var></b> message and if no <b><var>PUBACK</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBLISH</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>In case of QoS = 2</p>
<blockquote>
 Sends the <b><var>PUBLISH</var></b> message and if no <b><var>PUBREC</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBLISH</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<blockquote>
 After the <b><var>PUBREC</var></b> message has been received, it sends the <b><var>PUBREL</var></b> message 
  and if no <b><var>PUBCOMP</var></b> has been received in the timeout period,
  it can retry the <b><var>PUBREL</var></b> according to the <property>Retry</property> and <property>RetryInterval</property> settings,
  before giving up and returning with an error.
</blockquote>
<p>Usage example:</p>
<example>
Set message = ##class(Net.MQTT.Message).%New()
Set message.Topic = "/isctest/client/sent"
Set message.Content = 1
Set message.QoSLevel = 2
 
Set client = ##class(Net.MQTT.Client).%New()
Set client.Host = "test.mosquitto.org"
Set client.ClientId = "My1stMQTTClient"
Set client.traceTarget = "^MQTT.Trace"
Set sc = client.StartAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.Publish(message) If ('sc) { Do $System.OBJ.DisplayError(sc) }
Set sc = client.StopAgent() If ('sc) { Do $System.OBJ.DisplayError(sc) }
ZWrite ^MQTT.Trace
</example>]]></Description>
<FormalSpec>pMessage:Net.MQTT.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ..agent = "" {
		Quit $$$ERROR($$$GeneralError, "MQTT Agent to <" _ ..Host _ ":" _ ..Port _ "> has not been started yet")
	}
	If '$IsObject(pMessage) {
		Quit $$$ERROR($$$GeneralError, "A message must be specified to publish")
	}
	
	Set tSC = $$$OK
	If pMessage.QoSLevel > 0 {
		Set pMessage.MessageId = ##class(Net.MQTT.Aux.MessageCounter).NextMessageId(..ClientId, .tSC)
		Set:$$$ISOK(tSC) tSC = ##class(Net.MQTT.Aux.MessageStatus).RegisterMessageOut(..ClientId, pMessage.MessageId)
	}
	If $$$ISERR(tSC) {
		$$$MQTTTraceERR($System.Status.GetErrorText(tSC))
		Quit $$$ERROR($$$GeneralError, "Message ID for PUBLISH message cannot be created")
	}
	
	Set msg				= ##class(Net.MQTT.MessageStore).%New()
	Set msg.ClientId	= ..ClientId
	Set msg.Direction	= "O"
	Set msg.MessageId	= pMessage.MessageId
	Set msg.QoSLevel	= pMessage.QoSLevel
	Set msg.Retain		= pMessage.Retain
	Set msg.Topic		= pMessage.Topic
	Set msg.Content		= pMessage.Content
	Set tSC = msg.%Save()
	
	Set retry = ..Retry, retcnt = 0, success = 0
	Set acktype = $Case(pMessage.QoSLevel, 2: "PUBREC", 1: "PUBACK", : "")
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Aux.TaskList).WaitTask(..connectionId, msg.%Id() _ $Select(retcnt: ":" _ retcnt, 1: ""), "PUBLISH", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not succeeded within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			ElseIf pMessage.QoSLevel = 0 {
				Set success = 1
			}
			ElseIf pMessage.QoSLevel > 0 {
				Set ack = ##class(Net.MQTT.Aux.TaskList).WaitAck(..connectionId, pMessage.MessageId, acktype, ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
				ElseIf pMessage.QoSLevel = 2 {
					Set tSC = ..PublishQoS2(pMessage.MessageId)
				}
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="PublishQoS2">
<Description><![CDATA[
Internal method, used by <method>Publish</method> to manage the second pahse of QoS Level 2 message flow
(<b><var>PUBREL</var></b> message is sent and <b><var>PUBCOMP</var></b> is expected).]]></Description>
<Internal>1</Internal>
<FormalSpec>pMessageId:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	
	Set retry = ..Retry, retcnt = 0, success = 0
	While $$$ISOK(tSC) && (success '= 1) {
		Set ret = ##class(Net.MQTT.Aux.TaskList).WaitTask(..connectionId, pMessageId _ $Select(retcnt: ":" _ retcnt, 1: ""), "PUBREL", ..ReadTimeout, .tSC)
		If $$$ISOK(tSC) {
			If $ListGet(ret, 1) < 1 {
				Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not sent QoS=2 acknowledge within the timeout period (" _ $ListGet(ret, 1) _ ")")
			}
			ElseIf $ListGet(ret, 2) '= "" {
				Set tSC = $$$ERROR($$$GeneralError, $ListGet(ret, 2))
			}
			Else {
				Set ack = ##class(Net.MQTT.Aux.TaskList).WaitAck(..connectionId, pMessageId, "PUBCOMP", ..ReadTimeout)
				Set success  = $ListGet(ack, 1)
				If (success = 0) && (retry > 0) {
					$$$MQTTTraceERR("MQTT Agent has not received QOS=2 acknowledge within the timeout period (remaining reties: " _ retry _ ")")
					Hang ..RetryInterval
					Set retry = retry - 1, retcnt = retcnt + 1
				}
				If success < 1 {
					Set tSC = $$$ERROR($$$GeneralError, "MQTT Agent has not received QOS=2 acknowledge within the timeout period (" _ success _ ")")
				}
				ElseIf $ListGet(ack, 2) '= "" {
					Set tSC = $$$ERROR($$$GeneralError, $ListGet(ack, 2))
				}
			}
		}
	}
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetProtocolName">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..GetUTFString("MQIsdp")
]]></Implementation>
</Method>

<Method name="GetProtocolVersion">
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[$Char(3)
]]></Implementation>
</Method>

<Method name="GetUTFString">
<FormalSpec>pString:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	Quit ""
]]></Implementation>
</Method>

<Method name="ResetClient">
<Description><![CDATA[
For maintenance purposes only! <b>USE WITH CARE!</b>
<p>If one of the message flows would break with unexpected error, the <class>Net.MQTT.Client</class> may leave
 records behind in some auxiliary classes which can prevent the same <property>ClientId</property> to be used in a subsequent
 execution of a <class>Net.MQTT.Client</class> instance.</p>
<p>This auxiliary method is responsible for clearing those records when needed.</p>
<p><b>WARNING:</b> if this is called while a <class>Net.MQTT.Agent</class> with the same Client ID is still active,
 this may cause errors in the Agent, too. And stopping the Agent in a clear way (with sending a <b><var>DISCONNECT</var></b> message)
 won't be possible any more. Use <method>KillAgent</method> in this case!</p>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClientId:%String</FormalSpec>
<Implementation><![CDATA[
	Do ##class(Net.MQTT.Aux.MessageCounter).%DeleteId(pClientId)
	&sql(DELETE FROM Net_MQTT_Aux.Subscription WHERE ClientId = :pClientId)
	&sql(DELETE FROM Net_MQTT_Aux.MessageStatus WHERE ClientId = :pClientId)
]]></Implementation>
</Method>
</Class>


<Class name="Net.MQTT.Message">
<Description><![CDATA[
This structure is used as the input / output parameter type of multiple <class>Net.MQTT.Client</clas> methods.]]></Description>
<Super>%RegisteredObject,%XML.Adaptor</Super>
<TimeChanged>64072,56878.382273</TimeChanged>
<TimeCreated>64043,42166.491302</TimeCreated>

<Property name="MessageId">
<Description>
Message Identifier. Usually it doesn't have to be set, when used as an input parameter. </Description>
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="65535"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Topic">
<Type>%String</Type>
</Property>

<Property name="Content">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Description><![CDATA[
Quality of service, expected / provided by the client.<ul>
<li><b><var>0</var></b> - no guaranteed message delivery.</li>
<li><b><var>1</var></b> - at least once delivery (simple acknowledge).</li>
<li><b><var>2</var></b> - exactly once delivery (two level acknowledges).</li>
</ul>]]></Description>
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Description><![CDATA[
In case of subscriptions, this is the quality of service, provided by the server (may differ from the one expected by the client).
<br/>For details see <property>QoSLevel</property>]]></Description>
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="Retain">
<Description>
In some message flows (publish, subscribe) may show, whether the server is expected to keep the message,
 even after the client disconnects.</Description>
<Type>%Boolean</Type>
</Property>
</Class>


<Class name="Net.MQTT.MessageStore">
<Description><![CDATA[
Sample message store for messages published by or recieved by <class>Net.MQTT.Client</class> and <class>Net.MQTT.Agent</class> instances.
<p>This could be implemented different ways. For example: this implementation does not care about duplicate messages.</p>
<p>In this sample MQTT Client implementation this class just stores all the incoming and outgoing messages unconditionally.</p>
<p>For more documentation of message properties see: <class>Net.MQTT.Message</class>.</p>]]></Description>
<Super>%Persistent</Super>
<TimeChanged>64072,57252.367978</TimeChanged>
<TimeCreated>64050,80453.857656</TimeCreated>

<Index name="MsgIdx">
<Properties>ClientId,Topic</Properties>
</Index>

<Property name="ClientId">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN" value="23"/>
</Property>

<Property name="Topic">
<Type>%String</Type>
<Required>1</Required>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Direction">
<Description><![CDATA[
Direction of the message: <b><var>I</var></b> is for <var>input</var> (subscribe), <b><var>O</var></b> is for <var>output</var> (publish). ]]></Description>
<Type>%String</Type>
<InitialExpression>"I"</InitialExpression>
<Required>1</Required>
<Parameter name="VALUELIST" value=",I,O"/>
</Property>

<Property name="MessageId">
<Type>%Integer</Type>
<Parameter name="MAXVAL" value="65653"/>
<Parameter name="MINVAL" value="1"/>
</Property>

<Property name="Content">
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="QoSLevel">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="GrantedQoS">
<Type>%Integer</Type>
<Parameter name="VALUELIST" value=",0,1,2"/>
</Property>

<Property name="Retain">
<Type>%Boolean</Type>
</Property>

<Property name="CreatedAt">
<Type>%TimeStamp</Type>
<InitialExpression>$ZDateTime($ZTimestamp, 3)</InitialExpression>
<Required>1</Required>
</Property>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Net.MQTT.MessageStoreD</DataLocation>
<DefaultData>MessageStoreDefaultData</DefaultData>
<IdLocation>^Net.MQTT.MessageStoreD</IdLocation>
<IndexLocation>^Net.MQTT.MessageStoreI</IndexLocation>
<StreamLocation>^Net.MQTT.MessageStoreS</StreamLocation>
<Data name="MessageStoreDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>ClientId</Value>
</Value>
<Value name="3">
<Value>Topic</Value>
</Value>
<Value name="4">
<Value>MessageId</Value>
</Value>
<Value name="5">
<Value>Content</Value>
</Value>
<Value name="6">
<Value>QoSLevel</Value>
</Value>
<Value name="7">
<Value>GrantedQoS</Value>
</Value>
<Value name="8">
<Value>Retain</Value>
</Value>
<Value name="9">
<Value>CreatedAt</Value>
</Value>
<Value name="10">
<Value>Direction</Value>
</Value>
</Data>
</Storage>
</Class>
</Export>
